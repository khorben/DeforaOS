<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.2//EN">


<book>
<bookinfo>
	<title>DeforaOS Project Reference</title>
	<author>
		<firstname>Pierre</firstname><surname>Pronchery</surname>
		<affiliation>
			<address>
				<email>pierre@defora.org</email>
			</address>
		</affiliation>
	</author>
	<copyright>
		<year>2004</year>
		<holder>Pierre Pronchery</holder>
	</copyright>
</bookinfo>


<preface>
	<title>Introduction</title>
	<para>
Nowadays mainly two conceptions of computing compete: open source and proprietary software. I believe that most software should be available with its source code, as a proof of quality, interoperability, and security, to only quote the most obvious reasons.
	</para>
	<para>
However, most open source operating systems are based on UNIX. While this can be considered as a mature, stable and portable operating system, its use can be cryptic, and users are often facing technical inner workings of this system. Moreover, most human-computer interfaces, either in text or graphical mode, and even configuration files, are incoherent between each other, and particularly in community open source systems.
	</para>
	<para>
It is also certainly worth thinking about a technical re-design of the UNIX system. It has been originally designed along with C, with a monokernel approach, on computers where every single characted handling avoided counted. Now the power of even 10 years old computers is far beyond this, and researchers are working on micro-kernels, and safe programming languages for instance.
	</para>
	<para>
Today I think my ideal operating system should be open source, micro-kernel based, usable on pentium-class computers, coherent, connected, and distributed. This paper explains in detail how I would design and implement it.
	</para>
</preface>

<chapter>
	<title>Project orientations</title>
	<sect1>
		<title>Open source</title>
<!--
- interoperability
- ...
- security
- conclude with community open source limitations for coordination etc
- for everything: pros and cons
-->
		<para>
FIXME
		</para>
	</sect1>
	<sect1>
		<title>Usability</title>
<!--
- introduce with community open source coherence etc problem
- UNIX pros and cons (what to keep, and what not)
- coherence
- user-proof
=> developped by a small and tight team
=> remain transparent, accept external contributions
-->
		<para>
FIXME
		</para>
	</sect1>
	<sect1>
		<title>Technical choices</title>
		<sect2>
			<title>Micro kernel</title>
			<para>
FIXME
			</para>
		</sect2>
		<sect2>
			<title>Programming languages</title>
			<para>
FIXME
			</para>
		</sect2>
		<sect2>
			<title>Applications</title>
<!--
- application engine
- application interfaces
- messages
- toolkit programming interface
-->
			<para>
Every application runs inside what's called a "session". They are split in two parts: the application "engine", and the "interface". The end-user interaction should be presented the same way in text mode or graphical mode, possibly via the same API, and using only one binary for both.
			</para>
			<sect3>
				<title>Sessions</title>
				<para>
FIXME
				</para>
			</sect3>
			<sect3>
				<title>Applications engines</title>
				<para>
FIXME
				</para>
			</sect3>
			<sect3>
				<title>Applications interfaces</title>
				<para>
FIXME
				</para>
				<para>
The applications interfaces may detect the requested toolkit to use according to the availability of an environment variable ("DISPLAY" for instance), or by the result of an equivalent to the POSIX istty() call. Some applications may work with character streams as a fallback, typically like the UNIX filtering applications.
				</para>
			</sect3>
			<sect3>
				<title>Interface toolkits</title>
				<para>
FIXME
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Graphical server</title>
<!--
- client-side toolkit?
-->
			<para>
The graphics library would be fully OpenGL compliant. It is not yet known how the clients will communicate with the graphical server. In case of a socket based communication (maybe implemented anyway to run on other OSes), instead of the current kernel based one, the network transparency will be straight-forward. It may not be efficient though... This will be decided later.
			</para>
			<para>
About the graphical toolkit for applications, I insist that only one library will be supported, and binary compatible with the text mode toolkit. It may be more efficient to implement the toolkit on the server side, this will be decided later too.
			</para>
		</sect2>
	</sect1>
</chapter>

<chapter>
	<title>Detailed design</title>
<!--
- filesystem: keep what's good in UNIX, present it in a friendlier way
- APIs
  * C library:
    . str*() => string_*() and buffer_*()
    . C classes => String?, Buffer?, SList, DList, Hash, Config, ...
- sessions
  * sessions manager/init => itself a session? => can log on it and set it up?
  * system sessions/engines (services)
  * user sessions
- inter process communications
- login process
  * one can even login on a system service as if would join an existing session, and the setup and monitoring interfaces appear (make this possible generally from a user's session, and you've got the control panel)
-->
	<para>
FIXME
	</para>
</chapter>

<chapter>
	<title>Implementation process</title>
	<sect1>
		<title>Development policies</title>
		<sect2>
			<title>Validation process</title>
			<orderedlist>
				<listitem><para>Make it just work</para></listitem>
				<listitem><para>Audit</para></listitem>
				<listitem><para>Optimize</para></listitem>
				<listitem><para>Audit</para></listitem>
				<listitem><para>Think about possible features</para></listitem>
				<listitem><para>If globally accepted, add selected features</para></listitem>
				<listitem><para>Audit</para></listitem>
			</orderedlist>
		</sect2>
		<sect2>
			<title>Code conventions</title>
			<para>
FIXME
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Development tasks</title>
		<para>
It seems reasonable, if not obvious, to determine independant tasks within the huge work described before in this document. There follows a proposal.
		</para>
		<sect2>
			<title>Global tasks</title>
			<sect3>
				<title>Communication</title>
				<para>
FIXME
				</para>
			</sect3>
			<sect3>
				<title>Programming interfaces</title>
				<para>
FIXME
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Cooperation tasks</title>
			<sect3>
				<title>Documentations</title>
				<para>
FIXME
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Low-level applications</title>
			<sect3>
				<title>Assembler</title>
				<para>
FIXME
				</para>
			</sect3>
			<sect3>
				<title>C compiler</title>
				<para>
FIXME
				</para>
			</sect3>
			<sect3>
				<title>Micro-kernel</title>
				<para>
FIXME
				</para>
			</sect3>
			<sect3>
				<title>C library</title>
				<para>
FIXME
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>System applications</title>
			<sect3>
				<title>General purpose services</title>
				<para>
These applications only require their application engines. For an easy and safe configuration, or monitoring, they may provide user interfaces though.
				</para>
			</sect3>
			<sect3>
				<title>Text mode toolkit</title>
				<para>
FIXME
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>End-user applications</title>
			<para>
Every application that fits on a desktop: file browser, web browser, mail and news reader, messaging application, images viewer, audio and video viewer, and optionnaly games, etc.
			</para>
		</sect2>
		<sect2>
			<title>Graphics</title>
			<sect3>
				<title>Graphical server</title>
				<para>
FIXME
				</para>
			</sect3>
			<sect3>
				<title>Graphical mode toolkit</title>
				<para>
FIXME
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Services</title>
			<sect3>
				<title>General purpose daemons</title>
				<para>
FIXME
				</para>
			</sect3>
			<sect3>
				<title>Networking daemons</title>
				<para>
FIXME
				</para>
			</sect3>
			<sect3>
				<title>User interfaces</title>
				<para>
The only essential part of these services is their application engines.
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>POSIX environment</title>
			<para>
At the moment it is not yet known if the system will be based on, or provide a native POSIX development environment.
			</para>
			<para>
It may be possible to write an application engine providing the POSIX system and library calls, on which the POSIX utilities would connect as usual application interfaces. We could even imagine them with a graphical interface, which would fallback as the regular UNIX commands if the graphical toolkit is denied (using stdin, stdout and stderr as usual).
			</para>
		</sect2>
	</sect1>
</chapter>

</book>
