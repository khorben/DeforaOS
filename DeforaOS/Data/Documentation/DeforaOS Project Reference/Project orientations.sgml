<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook V4.2//EN">


<chapter>
	<title>Project orientations</title>
<!--
- for everything: pros and cons
-->
	<sect1>
		<title>Open source</title>
		<sect2>
			<title>Project licenses</title>
			<para>
This section contains the major software licenses used in the project, either for application source code, documentation, or any other file contained in the system.
			</para>
			<para>
The choices of these licenses are explained in the next section of this document.
			</para>
			<sect3>
				<title>Global source code</title>
				<para>
The terms of this license are extracted from the "Open Source Definition", thus it should be compatible with the original terms.
				</para>
				<screen>
DeforaOS project licensing terms
--------------------------------



Preamble
--------
"the author" in this license is myself, Pierre Pronchery.


Introduction
------------
The use of the software distributed as part of the DeforaOS project must comply
with the following criteria. The concerned software includes at least the
following (unless explictly mentionned by the author):
- every software contained in the project "DeforaOS".
- every software distributed on the DeforaOS project website,
  "http://www.defora.org", belonging to the author.


1. Free Redistribution
----------------------
Anyone is free to sell or give away the software, as a component of an
aggregate software distribution containing programs from several different
sources. Not royalty or any fee is required to do this.


2. Source Code
--------------
Distribution of the software is allowed in source code as well as compiled form.
Where some form of the product is not distributed with source code, there must
be a well-publicized means of obtaining the source code, not exceeding the cost
of an average internet download. The preferred form of modification is of source
code, via the unified diff format. It is not allowed to obfuscate source code in
any way, or to use any intermediate compilation format.


3. Derived Works
----------------
Modifications and derived works are tolerated. They must be distributed
according to the terms of this license. Moreover, the author kindly asks anyone
working on such modifications or works to keep him informed of these. The aim is
to let them benefit to everyone, and keep the best version of the software, and
related works, available at the original place (as a matter of global coherence,
and ease of use).


4. Integrity Of The Author's Source Code
----------------------------------------
Any modification of the source code, must be distributed as patch files,
according to the unified diff format. Distribution of software built from
modified source code is allowed. Derived works must carry the same name, and
must modify the version number this way: "original.version.number-vendor_name".


5. No Discrimination Against Persons Or Groups
----------------------------------------------
This license doesn't discriminate against any person or group of persons.


6. No Discrimination Against Fields Of Endeavor
-----------------------------------------------
This license does not restrict anyone from making use of the software in a
specific field of endeavor.


7. Distribution Of License
--------------------------
The rights attached to the software apply to all to whom the software is
redistributed, without the need for execution of an additional license by those
parties.


8. License Must Not Be Specific To A Product
--------------------------------------------
The rights attached to the program do not depend of any other licensing rights.


9. License Must Not Restrict Other Software
-------------------------------------------
This license does not place restrictions on other software that is distributed
along with the licensed software.


10. License Must Be Technology-Neutral
--------------------------------------
No provision of the license may be predicated on any individual technology or
style or interface.
				</screen>
			</sect3>
			<sect3>
				<title>Documentation</title>
				<para>
FIXME: not decided yet
				</para>
			</sect3>
			<sect3>
				<title>Other files</title>
				<para>
FIXME: depends if they're already copyrighted or not, etc, else not decided yet
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Fundamental liberties</title>
			<para>
The philosophy carried with the project licenses is to give as much freedom as possible to its users. They are basically allowed to use, distribute, and study without permission the concerned software. Two important points are mentioned though:
			</para>
			<itemizedlist>
				<listitem><para>modifications should be submitted to the current authors of the project, so that they can benefit to everyone</para></listitem>
				<listitem><para>consequently, forks of concerned software, contained in this project, should not be started (so that development efforts can be shared as much as possible)</para></listitem>
			</itemizedlist>
			<para>
These points are not absolutely mandatory because I am convinced that this development model is the best, even if as a software author I can't guarantee that I'll get rewarded for my work. In case of abuse of concerned software, I will certainly change this project license terms.
			</para>
		</sect2>
		<sect2>
			<title>Other considerations</title>
<!--
- open => remain transparent, accept external contributions
-->
			<para>
Of course I am not supporting free software without a reason. There are even many actually, which I can sum up here:
			</para>
			<itemizedlist>
				<listitem><para>interoperability: availability of the source code, transparency of the development process, and whenever possible strict adherence to the standards guarantee the users that they will be able to work even in heterogeneous environments.</para></listitem>
				<listitem><para>security: availability of the source code guarantees that the software is exempt of intentional malicious code, and is possibly being used or auditable by competent persons.</para></listitem>
				<listitem><para>perennity: availability of the source code guarantees that the software can be supported by third-party organisms at any time, and in a fair competition environment.</para></listitem>
			</itemizedlist>
			<para>
Not everything is perfect though, there is one point I sometimes have to deal with, the global coherence of open-source projects. Of course they are not initially designed for a single platform, and it's the duty of software distributors to adapt them to their own environment. That's where I think there is a place for big improvement: I feel the need of a complete platform project: fully open source, which it would develop itself. And even then, to remain coherent this certainly requires a tight team, and smaller the better.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Usability</title>
		<sect2>
			<title>Existing systems experiences</title>
			<sect3>
				<title>UNIX</title>
				<para>
FIXME:
- 200 distributions, few major applications per usage
- simple concepts
- light and flexible historical inheritances within more than 30 years
- sophisticated yet flexible and clear setup
- appropriate software versions handling
- localization ease
- things like they are
- different development models, including open source...
				</para>
			</sect3>
			<sect3>
				<title>Windows</title>
				<para>
FIXME:
- few distributions, 200 major applications per usage
- complex concepts
- heavy historical inheritances within a few years
- registry
- DLL hell
- localization issues
- original terms renamed and appropriated
- closed and lazy development where monopoly, aggressive standards conformance policy else (and often buggy too)
- .Net/WinForms/XAML paradoxor
				</para>
			</sect3>
			<sect3>
				<title>Others</title>
				<para>
FIXME:
- so few...
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>User orientation</title>
			<para>
FIXME: always think like the users, and listen to them...
			</para>
		</sect2>
		<sect2>
			<title>Usage samples</title>
			<para>
FIXME: a few words, and conceptual screen shots, about it would feel like to use the system...
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Technical choices</title>
		<sect2>
			<title>Micro kernel</title>
			<sect3>
				<title>Booting</title>
				<para>
The system will boot with a minimal filesystem image in memory, mounting the system directory from a location hard-coded in the image, or a bootloader parameter. Additional volumes will be directly available in the volumes hierarchy, and eventually mapped to the user defined applications and data files hierarchies.
				</para>
			</sect3>
			<sect3>
				<title>Drivers</title>
				<para>
They actually are applications engines, with the appropriate memory mappings and other priviledges necessary in their very purpose.
				</para>
				<para>
Applications using the drivers connect to them like interfaces usually do.
				</para>
			</sect3>
			<sect3>
				<title>Virtual File System</title>
				<para>
Interface proxy to the filesystems drivers. Knows the filesystems mappings. Maintains the pid/fd mappings. Only interface allowed to connect to the filesystems drivers. Sanitizes all accesses (handles and removes special path like ".", "..", etc).
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Programming languages</title>
			<para>
First, I want to avoid as much as possible to use assembly code. This is for obvious portability and readability reasons. I believe the micro-kernel should be coded in both assembly and C, because it has to be written with the computer limits and inner workings in mind. Object abstraction (in the programming language) is not necessary in the case of the kernel to my mind.
			</para>
			<para>
I am also thinking about using C in the whole base system:
			</para>
			<itemizedlist>
				<listitem><para>Ada: no, but it could be very interesting</para></listitem>
				<listitem><para>Assembly: no, long to write, too close to the machine</para></listitem>
				<listitem><para>C: yes, simpler to implement (and kind of mandatory anyway), few keywords, total liberty in APIs definitions, even if lacks exceptions, and is too close to the assembly language (then again we can handle the machine limits, ...if we think each time about each possibility)</para></listitem>
				<listitem><para>C++: no, bloat, hell to implement</para></listitem>
				<listitem><para>C#: no, I still have to look better at it</para></listitem>
				<listitem><para>D: no, doesn't look mature yet</para></listitem>
				<listitem><para>Java: no (virtual machine, verbosity of the language, classes names, ...)</para></listitem>
				<listitem><para>Objective C: no, though certainly interesting, but I find the syntax cryptic</para></listitem>
				<listitem><para>Perl: no, interpreter</para></listitem>
				<listitem><para>Python: no, interpreter</para></listitem>
			</itemizedlist>
			<para>
And also, as I care about coherence, the APIs in every language will be directly derived from a common definition, up to the point that every language would stick to its syntax, but could be compiled and linked against objects written in another one. If this is possible of course. Everything helping portability and interoperability will be appreciated.
			</para>
		</sect2>
		<sect2>
			<title>Applications</title>
<!--
- messages
- toolkit programming interface
-->
			<para>
Every application runs inside what's called a "session". They are split in two parts: the application "engine", and the "interface". The end-user interaction should be presented the same way in text mode or graphical mode, possibly via the same API, and using only one binary for both.
			</para>
			<sect3>
				<title>Sessions</title>
				<para>
The session program manages the applications running. It may start some automatically upon startup, or scheduled tasks, and remember its state upon close for next start. It keeps listening to the state of its child applications, possibly reacting to their behaviour (excessive resources usage, abnormal termination, ...).
				</para>
				<para>
It is also in charge of interaction between the applications engines and interfaces, and knows where to call or deport a call between engines (eg open an internet browser window on local engine, open an IRC engine application always on a distant server, ...). It can be considered as an applications engines directory.
				</para>
			</sect3>
			<sect3>
				<title>Applications engines</title>
				<para>
Application engines actually do their job, and keep their state, without handling any end-user interaction (but this doesn't prevent them to log messages for instance).
				</para>
			</sect3>
			<sect3>
				<title>Applications interfaces</title>
				<para>
Application interfaces are dedicated to the rendering and interaction with an application engine state. Ideally a given interface would propose identically either graphical, and text-mode graphical versions of the interface (and optionally a text only).
				</para>
				<para>
The applications interfaces may detect the requested toolkit to use according to the availability of an environment variable ("DISPLAY" for instance), or by the result of an equivalent to the POSIX istty() call. Some applications may work with character streams as a fallback, typically like the UNIX filtering applications.
				</para>
			</sect3>
			<sect3>
				<title>Interface toolkits</title>
				<para>
FIXME
				</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Graphical server</title>
<!--
- client-side toolkit?
-->
			<para>
The graphics library would be fully OpenGL compliant. It is not yet known how the clients will communicate with the graphical server. In case of a socket based communication (maybe implemented anyway to run on other OSes), instead of the current kernel based one, the network transparency will be straight-forward. It may not be efficient though... This will be decided later.
			</para>
			<para>
About the graphical toolkit for applications, I insist that only one library will be supported, and binary compatible with the text mode toolkit. It may be more efficient to implement the toolkit on the server side, this will be decided later too.
			</para>
		</sect2>
	</sect1>
</chapter>
